# A single weather reading
type Weather {
  stationId: String!
  name: String
  timezone: String
  temperature: Float
  humidity: Float
  windSpeed: Float
  rainRate: Float
  windDirection: Float
  lastUpdated: String
}

# An activity with score
type ActivityScore {
  activity: Activity!
  score: Int!
  message: String
}

enum Activity {
  SKIING
  SURFING
  INDOOR_SIGHTSEEING
  OUTDOOR_SIGHTSEEING
}

# Station object returned by suggestCities
type Station {
  id: ID!
  name: String
  country: String!
  stationId: String!
  latitude: Float
  longitude: Float
  weather: Weather
  activities: [ActivityScore!]!
}

# Pagination for suggestCities
type StationEdge {
  node: Station!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  endCursor: String
}

type StationConnection {
  edges: [StationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

# Query for suggesting cities/stations
type Query {
  suggestCities(query: String!, limit: Int = 8, after: String): StationConnection!
  getWeather(stationId: String!): WeatherResult!
  rankActivities(stationId: String!): [ActivityScore!]!
}

# Weather result union
union WeatherResult = Weather | WeatherError

# Error handling
enum WeatherErrorCode {
  STATION_NOT_FOUND
  INTERNAL_ERROR
  DATA_UNAVAILABLE
}

type WeatherError {
  code: WeatherErrorCode!
  message: String!
}

scalar JSON
# A successful city info response
type CityInfo {
  id: ID!
  name: String!
  stationId: String!
  country: String
  latitude: Float
  longitude: Float
  weather: Weather
  activities: [ActivityScore!]
}

# Possible errors
type CityError {
  code: CityErrorCode!
  message: String!
}

enum CityErrorCode {
  CITY_NOT_FOUND
  INVALID_QUERY
}

# Union type for the result
union CityInfoResult = CityInfo | CityError

type Mutation {
  fetchCityInfo(cityName: String!): CityInfoResult!
}
